#!/usr/bin/env ruby

require "base64"
require "fileutils"
require "tempfile"

# Create directory to store images if it does not already exist.
FileUtils.mkdir_p "README"

# Delete any previously exported files
Dir["./README/**/*"].each do |file|
  FileUtils.rm file
end

# Ensure bookstack auth for curl is present

## Assume we are using the default profile
PROFILE = `grep -E '^\\[Profile|^Path|^Default' ~/.mozilla/firefox/profiles.ini | grep -1 '^Default=1' | grep '^Path' | cut -c6-`.strip

## Create a file to cache session in so we don't have to fetch it every time
## this script runs
##
## If the file is not present or the cookie is expired, refetch (this will
## require closing firefox)
SESSION_CACHE_FILE=".session-cache"

def generate_session_cache_file
  command = %Q(sqlite3 -line ~/.mozilla/firefox/#{PROFILE}/cookies.sqlite "SELECT value, expiry FROM moz_cookies WHERE name = 'bookstack_session';" | sed -s 's/ //g')
  contents = `#{command}`
  File.write SESSION_CACHE_FILE, contents
  puts "Wrote new session cache file"
end

if File.exists? SESSION_CACHE_FILE
  puts "Found .session-cache"
  expiry = `grep expiry < #{SESSION_CACHE_FILE} | cut -d'=' -f2`.to_i
  if expiry < Time.now.to_i
    puts "Cookie is expired, attempting to fetch new one"
    generate_session_cache_file
  else
    puts "Cookie is valid"
  end
else
  puts "Missing .session-cache. Attempting to fetch new one"
  generate_session_cache_file
end

# Fetch the post
# In order to read from the cookie database, firefox will have to be closed
# (this will also ensure current value is flushed to db)
SESSION=`grep value < .session-cache | cut -d'=' -f2`.strip
command = %Q(curl 'http://localhost:8080/books/projects/page/creating-a-voxel-engine-from-scratch/export/html' --silent -H "Cookie: bookstack_session=#{SESSION}")
html = `#{command}`

# Extract the images
IMAGE_URL_REGEX=/(http:\/\/localhost:8080)?\/uploads\/images\/gallery\/\d{4}-\d{2}-\w{3}\/[a-zA-Z0-9_\-\.]+/
IMAGE_NAME_REGEX=/(http:\/\/localhost:8080)?\/uploads\/images\/gallery\/\d{4}-\d{2}-\w{3}\/\K[a-zA-Z0-9_\-\.]+/

DATA_REGEX=/data:image\/[^;]*;base64,[a-zA-Z0-9+\/=]*/
BASE64_REGEX=/data:image\/[^;]*;base64,\K[a-zA-Z0-9+\/=]*/

new_html = html.split("\n").map do |html_line|
  image_match = html_line.match(IMAGE_NAME_REGEX)
  if image_match
    puts ""

    image_name = image_match[0]
    puts "Found image #{image_name}"

    base64_match = html_line.match(BASE64_REGEX)
    raise "Found bookstack image but no base64" if !base64_match
    base64 = base64_match[0]

    local_image_path = "./README/#{image_name}"
    puts "Local image path: #{local_image_path}"

    IO.write local_image_path, Base64.decode64(base64)

    new_html_line = html_line
      .sub(IMAGE_URL_REGEX, local_image_path)
      .sub(DATA_REGEX, local_image_path)

    new_html_line
  else
    html_line
  end
end.join("\n")

Tempfile.create do |html_file|
  File.write html_file.path, new_html

  Tempfile.create do |readme_file|
    # Convert html file to github markdown
    # Remove the automatically included final section which contains metadata
    puts "\nConverting html to markdown"
    command = "reverse_markdown #{html_file.path} --github-flavored=true | tac | sed '0,/* * */d' | tac"
    markdown = `#{command}`.strip
    File.write readme_file.path, markdown

    puts "\nInserting table of contents"
    command = "cat #{readme_file.path} | ./bin/gh-md-toc - | sed 's/^[	 ]*//'"
    table_of_contents = `#{command}`.strip

    readme_contents = "**Table of Contents**\n\n" + table_of_contents + "\n\n" + markdown
    File.write "README.md", readme_contents
  end
end
